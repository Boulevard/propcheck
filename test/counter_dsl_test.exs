defmodule PropCheck.Test.CounterDSL do
  @moduledoc """
  This is a test of the modulo counter. There are several variants of test
  setups, to check that the DSL implementation is capable of shrinking
  failures due to ignoring the modulo features to a minimal set of steps.

  The statemachine model of the counter has only three states:
      * `init`: the counter is initialized
      * `zero`: the counter is reset to `0`
      * `one`: the counter has a value above `0`

  These states are reflected in the commands and for determining the
  weights of the commands.
  """
  use PropCheck
  use PropCheck.StateM.DSL
  use ExUnit.Case
  import ExUnit.CaptureIO
  require Logger

  alias PropCheck.Test.Counter

  @moduletag capture_log: true

  #########################################################################
  ### The properties
  #########################################################################

  property "infinity counter works fine", [:verbose] do
    forall cmds <- commands(__MODULE__) do
      trap_exit do
        {:ok, _pid} = Counter.start_link()
        events = run_commands(cmds)
        Counter.stop()

        (events.result == :ok)
        |> when_fail(
            IO.puts """
            History: #{inspect events.history, pretty: true}
            State: #{inspect events.state, pretty: true}
            Env: #{inspect events.env, pretty: true}
            Result: #{inspect events.result, pretty: true}
            """)
        |> aggregate(command_names cmds)
        |> measure("length of commands", length(cmds))
      end
    end
  end

  @tag will_fail: true
  property "modulo counter does not increment inifinite times", [:verbose] do
    Logger.error "This property will fail in order to show the shrinking results"
    Logger.error "It is excluded from the set of test for the travis build"
    forall cmds <- commands(__MODULE__) do
      trap_exit do
        {:ok, _pid} = Counter.start_link(5)
        events = run_commands(cmds)
        Counter.stop()

        (events.result == :ok)
        |> when_fail(
            IO.puts """
            History: #{inspect events.history, pretty: true}
            State: #{inspect events.state, pretty: true}
            Env: #{inspect events.env, pretty: true}
            Result: #{inspect events.result, pretty: true}
            """)
        |> aggregate(command_names cmds)
        |> measure("length of commands", length(cmds))
      end
    end
  end
  #########################################################################
  ### Some tests of command generation and shrinking
  #########################################################################

  test "shrink the commands" do
    shrinkings = capture_io(fn -> sample_shrink(commands(__MODULE__), 10) end)
    # Ensure that each list of commands begins with the sequence '[{init,'
    # this means that (except for the empty list) only command sequences
    # which start in state `:init` are generated by shrinking.
    cmd_matcher = ~r/^(\[{init,)|(\[\])|( ).*/
    {:ok, shrinks} = StringIO.open(shrinkings)
    assert shrinks
    |> IO.stream(:line)
    |> Enum.all?(&Regex.match?(cmd_matcher, &1))
  end

  #########################################################################
  ### The model
  #########################################################################

  def initial_state(), do: :init

  def weight(:init), do: [inc: 1, clear: 1]
  def weight(_), do: [get: 1, inc: 2, clear: 1]

  defcommand :inc do
    def impl(), do: Counter.inc()
    def args(_), do: []
    def next(:init, [], _res), do: :zero
    def next(:zero, [], _res), do: :one
    def next(:one, [], _res), do: :one
    def post(:init, [], res), do: res == 0
    def post(:zero, [], res), do: res > 0
    def post(:one, [], res), do: res > 0
  end

  defcommand :get do
    def impl(), do: Counter.get()
    def args(_), do: []
    def post(_state, [], res), do: res >= 0
    def pre(:init, _, _), do: false
    def pre(_, _, _), do: true
  end

  defcommand :clear do
    def impl(), do: Counter.clear()
    def args(_), do: []
    def next(_state, [], _res), do: :zero
    def post(_state, [], res), do: res == :ok
  end

end
